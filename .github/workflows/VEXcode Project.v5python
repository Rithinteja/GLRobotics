{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nleft_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nright_motor_b = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)\nspinwheel_motor = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nintake_motor = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\nroller_motor = Motor(Ports.PORT7, GearSetting.RATIO_18_1, False)\ncontroller_1 = Controller(PRIMARY)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_left_shoulder_control_motors_stopped = True\ncontroller_1_right_shoulder_control_motors_stopped = True\ncontroller_1_up_down_buttons_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global controller_1_left_shoulder_control_motors_stopped, controller_1_right_shoulder_control_motors_stopped, controller_1_up_down_buttons_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonL1/buttonL2 status\n            # to control intake_motor\n            if controller_1.buttonL1.pressing():\n                intake_motor.spin(FORWARD)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif controller_1.buttonL2.pressing():\n                intake_motor.spin(REVERSE)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif not controller_1_left_shoulder_control_motors_stopped:\n                intake_motor.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_left_shoulder_control_motors_stopped = True\n            # check the buttonR1/buttonR2 status\n            # to control spinwheel_motor\n            if controller_1.buttonR1.pressing():\n                spinwheel_motor.spin(FORWARD)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif controller_1.buttonR2.pressing():\n                spinwheel_motor.spin(REVERSE)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif not controller_1_right_shoulder_control_motors_stopped:\n                spinwheel_motor.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_right_shoulder_control_motors_stopped = True\n            # check the buttonUp/buttonDown status\n            # to control roller_motor\n            if controller_1.buttonUp.pressing():\n                roller_motor.spin(FORWARD)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif controller_1.buttonDown.pressing():\n                roller_motor.spin(REVERSE)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif not controller_1_up_down_buttons_control_motors_stopped:\n                roller_motor.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_up_down_buttons_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n#endregion VEXcode Generated Robot Configuration\nmyVariable = 0\n\ndef when_started1():\n    global myVariable\n    pass\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[1,2,3,4,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"}},{"port":[5],"name":"spinwheel_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[6],"name":"intake_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[7],"name":"roller_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"intake_motor","leftDir":"false","right":"spinwheel_motor","rightDir":"false","upDown":"roller_motor","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"}}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"","minVersion":"2.4.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}